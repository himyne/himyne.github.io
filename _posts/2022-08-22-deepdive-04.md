---
published: true
layout : single
title : "[JS] 모던 Javascript Deep Dive 4장 - 변수"

categories:
  - DeepDive
tags:
  - Deepdive
---

이전까지는 미리 알아두어야 할 자바스크립트 관련 상식이었다면 변수부터는 본격적인 언어 공부의 시작이다. 작은 글씨까지 책의 내용을 최대한 다 훓고 기억해놔야 할 내용들만 뽑아 정리할 예정이다.

## 4.1 변수란 무엇인가? 왜 필요한가?

### ⚠ **컴퓨터로 10+20 연산을 어떻게 할까?**

---

간단한 수식 계산을 할 때, 사람도 숫자와 기호의 의미를 알아야 할 수 있듯이 자바스크립트 엔진도 사람과 유사한 방식으로 코드를 실행한다.

컴퓨터는 **CPU**를 사용해 **연산**하고 **메모리**를 사용해 **데이터를 기억**한다.

예를 들자면 10+20 연산을 할 때,숫자 값(10,20)은 메모리 상의 임의의 위치에 기억되고 CPU는 이 값을 읽어들여 연산을 수행한다. 

이제 10+20은 CPU를 통해 연산이 끝났고 만들어진 결과값 30 또한 메모리 어딘가에 저장되었다. 

연산결과인 30을 재사용하려면 메모리 주소를 통해 메모리 공간에 직접 접근해야하는데 이 방식은 치명적 오류를 발생시킬 수 있어 올바른 방법이 아니다.

이 때문에 **저장된 값을 읽어 들여 재사용할 수 있는 “변수”가 필요**한 것이다.
```
📝 변수란?
변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 값의 위치를 가리키는 상징적인 이름이다.
```


변수는 var,let,const 키워드를 사용하여 **선언**하고 할당 연산자를 사용해 값을 **할당**한다. 그리고 식별자인 변수명을 사용해 변수에 저장된 값을 **참조**한다. 

```jsx
var score;  // 변수의 선언
score = 80; // 값의 할당
score = 90; // 값의 재할당
score;      // 변수의 참조

// 변수의 선언과 할당
var average = (50 + 100) / 2; 
```

## 4.2 식별자

식별자는 값이 아니라 메모리 주소를 기억한다. 

결국, 식별자는 메모리 주소에 붙인 이름이라고 할 수 있다.

식별자는 변수에만 국한되는 것은 아니고 **함수/클래스 등의 모든 이름은 식별자**이다. 

**네이밍 규칙**을 준수해야 하며, **선언**에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.

## 4.3 변수 선언

변수를 사용하려면 반드시 **선언이 필요**하다. 

변수를 선언할 때, 주로 var, let, const 키워드를 사용하는데 ES6에서 let,const 키워드가 도입되기 전까지는 var만 사용했다.

```
📝  var 키워드의 단점과 let/const 의 등장

var 키워드는 의도치 않게 전역 변수가 선언되어 심각한 부작용이 생기기도 하는 단점을 가지고 있다. ES5→ES6 변화 이후 추가된 let/const를 주로 쓰는 것이 권장된다. 
```

변수를 선언한 뒤 **값을 할당하지 않으면 undefined**가 암묵적으로 할당되어 초기화된다. 

**선언하지 않은 변수**에 접근하면 **ReferenceError**가 발생한다.

### ⚠ 변수 선언과 초기화

---

자바스크립트 엔진은 변수 선언을 할 때 아래 2가지 단계를 거친다.

1. **선언 단계** : 변수 이름을 등록해서 자바스크립트 엔진에 **변수의 존재를 알림**
2. **초기화 단계** : 값을 저장하기 위한 메모리 공간을 확보하고 **undefined를 할당**

*⇒ 초기화 단계를 거치지 않으면 ?*

이전에 다른 애플리케이션이 사용했던 **쓰레기 값**이 남아있을 수 있다. var 키워드는 암묵적으로 undefined를 할당하기 때문에 쓰레기 값이 나올 위험으로부터 안전하다.

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

```jsx
console.log(a); // undefined
var a; 
```

자바스크립트 코드는 **인터프리터에 의해 한 줄씩 순차적으로 실행**되어야 한다.

그런데 어떻게 변수 선언문보다 변수를 참조하는 코드가 앞에 있는데 어떻게 오류가 안나고 출력이 되었을까?

그 이유는 변수 선언이 소스코드가 한 줄 씩 순차적으로 실행되는 시점(런타임)이 아니라 그 **이전 단계에서 먼저 실행되기 때문**이다.

**자바스크립트 엔진은** 변수 선언이 소스코드의 어디에 있든 상관없이 **다른 코드보다 먼저 실행**한다는 것이다. 

이것이 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작한다 하여 **변수 호이스팅**이라고 한다.

## 4.5 값의 할당

할당 연산자 = 를 사용하여 변수에 값을 할당한다. 

변수 선언은 런타임 이전에 실행되고 값의 할당은 런타임에 실행된다

```jsx
var scroe; //변수의 선언
score = 80; //변수의 할당

var scroe = 80; //변수 선언과 값의 할당
```

변수 선언과 값의 할당을 한줄의 코드에 작성하여도 자바스크립트 엔진은 선언과 할당을 2개의 문으로 나누어 각각 실행한다.  변수에 undefined가 할당되어 초기화되는 것은 똑같다는 것이다.

## 4.6 값의 재할당

이미 값이 할당되어 있는 변수에 새로운 값을 다시 할당하는 것이 값의 재할당이다.

var 키워드로 선언한 변수는 값을 재할당할 수 있다.

값을 재할당할 수 없다면 변수가 아니라 상수라고 하는데 const 키워드를 사용하면 상수를 표현할 수 있다. 

```jsx
var score = 90;
score = 80; // 값의 재할당
```

 *변수에 값을 재할당하면 score 변수의 값이 80에서 90으로 변경되는데 이렇게 되면 80은 어떻게 될까?*

⇒ 이전 값 80이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 90을 새로 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 공간에 90을 채워넣는다. 더이상 필요하지 않은 값인 80은 가비지 콜렉터에 의해 메모리에서 자동 해제된다.

### 가비지 콜렉터

---

애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능

[자바스크립트 v8 엔진의 가비지 컬렉션 동작 방식](https://fe-developers.kakaoent.com/2022/220519-garbage-collection/)

